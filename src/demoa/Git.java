package demoa;

public class Git {
	// untracked  未跟踪的
	// unmodified 未修改的
	// modified   被改进的
	// staged     分期的(暂存)
	// status     状态
	// branch     分支
	// master     主要的
	// Changes    变化
	// ignore     忽略
	// current    当前的
	// directory  目录
	// insertions 插入物
	// deletions  删除
	// Merge      合并
	// remote     远程的
	// configured 配置
	// checkout   校验
	
	// commit object   提交对象
	// Fast-forward     快进
	// shared repository  共享的仓库
	// developer  开发者
	// blessed repository  神圣的仓库
	// integration manager  整合经理
    // developer public   开发者公共仓库
    // developer private  开发者私有仓库
	//  dictator  独裁者
	//  lieutenant  副官
	//  trailing whitespace  尾随空白
	//

	// git add 命令。这是个多功能命令：
	// 可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，
	// 还能用于合并时把有冲突的文件标记为已解决状态等。
	// 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要
	// 更加合适。

	// ---------------------------------------------------------

	// git status -s 命令或
	// git status --short 命令
	// 新添加的未跟踪文件前面有 ?? 标记，
	// 新添加到暂存区中的文件前面有 A 标记，
	// 修改过的文件前面有M 标记。你可能注意到了 M 有两个可以出现的位置，
	// 出现在右边的 M 表示该文件被修改了但是还没放入暂存区，
	// 出现在靠左边的 M 表示该文件被修改了并放入了暂存区。

	// ---------------------------------------------------------

	// 给 git commit 加上 -a 选项，
	// Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，
	// 从而跳过 git add 步骤
	// git commit -a -m 'added new benchmarks'

	// ---------------------------------------------------------

	// git diff 修改之后还没有暂存起来的变化内容。
	// 查看已暂存的将要添加到下次提交里的内容 git diff --cached
	// 更高版本还允许使用 git diff --staged 。
	
	// ---------------------------------------------------------
	
	// git rm  如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f
	// git rm --cached README 你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。
	
	// ---------------------------------------------------------
	
	// 要在 Git 中对文件改名 git mv file_from file_to
	
	// ---------------------------------------------------------
	
	// git log 会按提交时间列出所有的更新，最近的更新排在最上面。
	// 这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。
	// git log --stat 每次提交的简略的统计信息
	
	// git log -p -2 一个常用的选项是 -p ，用来显示每次提交的内容差异。
	// 你也可以加上 -2 来仅显示最近两次提交
	
	// git log --pretty=这个选项可以指定使用不同于默认格式的方式展示提交历史。
	// 例如 git log --pretty=format:"%h - %an, %ar : %s"
    // git log --pretty=oneline
	// git log --pretty=format:"%h %s" --graph
	// --graph显示 ASCII 图形表示的分支合并历史。
	
	//git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。
	
	// git log --since=2.weeks 限制输出长度，仅显示指定时间之后的提交。--after
	// --until ,--before 仅显示指定时间之前的提交。
	
	// ---------------------------------------------------------
	
	//撤消操作$ git commit -m 'initial commit'
	//      $ git add forgotten_file
	//      $ git commit --amend   第二次提交将代替第一次提交的结果。
	
	// git reset HEAD 文件名   来取消暂存
    // git checkout -- 文件名  撤消对文件的修改
	// git checkout -- [file] 是一个危险的命令，这很重要。你对那个文件做的任何修改
	// 都会消失，你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令。
	// 如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，保存进度与分支是更好的做法。
	
	// ---------------------------------------------------------
	
	// git remote 命令。它会列出你指定的每一个远程服务器的简写。
	// git remote -v 会显示需要读写远程仓库使用的简写（保存的）与其对应的 URL。
	// 与几个协作者合作的，拥有多个远程仓库的仓库会显而易见
	// git remote add <shortname> <url> 添加远程仓库，字符串shortname可以代替整个URL
	// git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。
	// 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。
	// 必须注意git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作，
	// 当准备好时你必须手动将其合并入你的工作。
	
	// git remote show [remote-name]会列出远程仓库的URL与跟踪分支的信息。
	// 远程仓库的移除与重命名 例如 git remote rename pb paul   将pb重命名为paul
	// 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了，
	// 可以使用 git remote rm [remote-name]
	
	// ---------------------------------------------------------
	
	// git tag -a v0.0.1 -m 'version 0.0.1' 创建附注标签
	// git push origin v0.0.1 共享标签到远程仓库服务器上
	
	// ---------------------------------------------------------
	
	// git checkout -b iss1  新建一个分支并同时切换到那个分支上，等同于以下两条命令 
	// git branch iss1
	// git checkout iss1
	
	// git checkout master 切换回master分支，在你切换分支之前，保持好一个干净的状态。
	// 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）
	
	// git merge hotfix 合并hotfix分支回你的master分支
	
	// 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，
	// 所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，
	// 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，
	// 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做
	// “快进（fast-forward）”。
	
	// 如果你的开发历史从一个更早的地方开始分叉开来（diverged），合并时会使用两个分支的末端所指的快照，
	// 以及这两个分支的工作祖先，做一个简单的三方合并。Git 会自行决定选取哪一个提交作为最优的共同祖先，
	// 并以此作为合并的基础
	// Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。
	// 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。
	
	// 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。
	// 产生合并冲突时Git 会暂停下来，等待你去解决合并产生的冲突。此时 Git 做了合并，
	// 但是没有自动地创建一个新的合并提交。
	// 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件
	
	// git branch -d hotfix 删除分支
	// git branch 命令不只是可以创建与删除分支。如果不加任何参数运行它，会得到当前所有分支的一个列表
	// 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令
	// 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged 
	// 查看所有包含未合并工作的分支，可以运行 git branch --no-merged
	// 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败
	// 如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。
	
	// git ls-remote (remote) 来显式地获得远程引用的完整列表。
	// 远程引用是对远程仓库的引用（指针），包括分支、标签等等。
	// git remote show [remote-name]会列出远程仓库的URL与跟踪分支的信息。
	
	
}
